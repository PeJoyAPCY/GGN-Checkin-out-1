<h2>üì∑ ‡∏£‡∏∞‡∏ö‡∏ö Check in / Check out</h2>

<div>
  <label><input type="radio" name="jobType" value="Check in"> Check in</label>
  <label><input type="radio" name="jobType" value="Check out"> Check out</label>
</div>

<input type="file" id="imageInput" accept="image/jpeg,image/png" multiple />
<textarea id="text" rows="2" placeholder="‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)"></textarea>
<div id="previewText"></div>
<button id="sendBtn">‡∏™‡πà‡∏á‡∏†‡∏≤‡∏û‡πÅ‡∏•‡∏∞ Log ‡πÄ‡∏Ç‡πâ‡∏≤ Telegram</button>

<div id="previewContainer"></div>
<div id="status"></div>
<canvas id="canvas"></canvas>

<script>
  const botToken = "8192684646:AAFU_kYwTM6_tG0VshfamEdyCqFxSr45OPk";
  const chatId = "-4802946167";

  const imageInput = document.getElementById("imageInput");
  const previewContainer = document.getElementById("previewContainer");
  const previewText = document.getElementById("previewText");
  const extraText = document.getElementById("text");
  const status = document.getElementById("status");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  let photos = [];
  let processedPhotos = [];
  let locationStr = "";

  function getSelectedJob() {
    const selected = document.querySelector('input[name="jobType"]:checked');
    return selected ? selected.value : "";
  }

  imageInput.addEventListener("change", (e) => {
    photos = Array.from(e.target.files).filter(file => {
      if (file.type === "image/heic" || file.name.endsWith(".heic")) {
        alert("‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå .heic ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏ä‡πâ .jpg ‡∏´‡∏£‡∏∑‡∏≠ .png");
        return false;
      }
      return true;
    });
    updatePreview();
  });

  function updatePreview() {
    previewContainer.innerHTML = "";
    photos.forEach(file => {
      const img = document.createElement("img");
      img.src = URL.createObjectURL(file);
      previewContainer.appendChild(img);
    });
  }

  function getLocation() {
    return new Promise((resolve) => {
      if (!navigator.geolocation) return resolve("");
      navigator.geolocation.getCurrentPosition(async pos => {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;
        try {
          const res = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&accept-language=th`);
          const data = await res.json();
          locationStr = data.display_name || `${lat.toFixed(6)},${lon.toFixed(6)}`;
        } catch {
          locationStr = `${lat.toFixed(6)},${lon.toFixed(6)}`;
        }
        updatePreviewText();
        resolve();
      }, () => resolve());
    });
  }

  function updatePreviewText() {
    const job = getSelectedJob() || "-";
    const extra = extraText.value.trim();
    const nowStr = new Date().toLocaleString("th-TH");
    previewText.textContent = `üìÖ ${nowStr}\nüìç ${locationStr}\nüìå ‡∏á‡∏≤‡∏ô: ${job}${extra ? `\nüìù ${extra}` : ""}`;
  }

  extraText.addEventListener("input", updatePreviewText);
  document.querySelectorAll('input[name="jobType"]').forEach(el => {
    el.addEventListener("change", updatePreviewText);
  });

  async function processImage(file) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(blob => resolve(blob), "image/jpeg", 0.9);
      };
      img.src = URL.createObjectURL(file);
    });
  }

  async function sendToTelegram() {
    if (photos.length === 0) return alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û");
    if (!getSelectedJob()) return alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏á‡∏≤‡∏ô");

    status.textContent = "üìç ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î...";
    await getLocation();

    const caption = previewText.textContent;
    const nowStr = new Date().toLocaleString("th-TH");
    const job = getSelectedJob();
    const extraMsg = extraText.value.trim();

    processedPhotos = [];

    for (let i = 0; i < photos.length; i++) {
      const blob = await processImage(photos[i]);
      const form = new FormData();
      form.append("chat_id", chatId);
      form.append("photo", blob, `photo${i + 1}.jpg`);
      form.append("caption", caption);

      await fetch(`https://api.telegram.org/bot${botToken}/sendPhoto`, {
        method: "POST",
        body: form
      });

      processedPhotos.push({ i: i + 1, nowStr, location: locationStr, job, extraMsg });
    }

    const wb = XLSX.utils.book_new();
    const data = [["‡∏•‡∏≥‡∏î‡∏±‡∏ö", "‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤", "‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà", "‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏á‡∏≤‡∏ô", "‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°"]];
    processedPhotos.forEach(p =>
      data.push([p.i, p.nowStr, p.location, p.job, p.extraMsg])
    );
    const ws = XLSX.utils.aoa_to_sheet(data);
    XLSX.utils.book_append_sheet(wb, ws, "Log");
    const wbout = XLSX.write(wb, { bookType: "xlsx", type: "array" });
    const excelBlob = new Blob([wbout], { type: "application/octet-stream" });

    const logForm = new FormData();
    logForm.append("chat_id", chatId);
    logForm.append("document", excelBlob, "log.xlsx");

    await fetch(`https://api.telegram.org/bot${botToken}/sendDocument`, {
      method: "POST",
      body: logForm
    });

    status.textContent = "‚úÖ ‡∏™‡πà‡∏á‡∏†‡∏≤‡∏û‡πÅ‡∏•‡∏∞ log ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß!";
    photos = [];
    updatePreview();
    previewText.textContent = "";
    extraText.value = "";
    document.querySelectorAll('input[name="jobType"]').forEach(el => el.checked = false);
  }

  document.getElementById("sendBtn").addEventListener("click", sendToTelegram);
</script>
